---
layout: post
title: "Stages of Compiling C Programs"
ecverpt: "Understanding the process of converting high level languages into machine code"
date: 2018-04-02 22:00:00
---

A computer's CPU does not understand high level languages such as C, Rust or English. Only two numbers make sense to the CPU, zeroes and ones. In this post we're going to understand how compilers like GCC make it easier for programmers to write and focus only on writing high level code while taking care of making the CPU understand that code.

We're going to be using GNU's compiler collection (GCC) as our C compiler.

### Input program

To keep things simple, we're going to use a simple hello world program as shown below

{%highlight c %}
/* helloWorld.c */
#include <stdio.h>

int main()
{
	printf("Hello World");
	return 0;
}
{% endhighlight %}

We're going to compile the code by invoking GCC with the {%highlight bash%}--save-temps{% endhighlight %} so that all the intermediate files created by GCC during the compilation files are saved for future inspection

## Stage 1 - Preprocessing 

The first stage is the preprocessing stage. This takes care of any line starting with a $$#$$. So header files, macros etc. are taken care of by the preprocessor. 

For example in our helloWorld.c program, the preprocessor replaces the line #include<stdio.h> with the contents of the stdio.h file. This file is generally included in your /usr/include directory. 

The preprocessor also replaces any occurences of macros declared using #define with he values they represent. 

Conditional compilation directives such as #if, #ifdef etc. are also taken care of by the preprocessor.

The output generated by the preprocessor is stored in a file with a .i extension.

One important thing to note here is that the preprocessed code does not contain the definitions for any library functions used. This comes at a later stage

## Stage 2 - Compilation (ikr)

The second stage is quite ironically the compilation stage. Here, the input is the .i file generated by the preprocessor. The compiler converts the .i file to assembly code targeted at the underlying CPU ISA. 

## Stage 3 - Assembly 

The assembly stage uses an assembler to convert the assembly code generated in stage 2 to machine code i.e binary code that the CPU can actually understand. The file generated is stored as a .o file. These files are not human readable but programs exist that can decipher such files. GCC uses the ELF file format for its object files while Windows' MSVC++ compiler uses the PE format. Both these formats are well documented so it is easily possible to decipher the object files.

## Stage 4 - Linking

This is the final stage of the compilation process where any uses of library functions are replaced with the actual function code present in other library files. This is where the actual code of the printf function we used in our program is retrieved for the CPU to understand. 


